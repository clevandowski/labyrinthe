<!DOCTYPE html>
<html lang="en-US">
<link rel="stylesheet" href="css/styles.css?v=1.0">
<script src="scripts/angular.js"></script>
<body>
<div ng-app="myApp" ng-controller="myCtrl">
  <div style="display: inline-block; position: relative;">
    <h1>
      | <span ng-click="listener.generate(labyrinthe, labyrinthe2)">Generate</span> | 
      <span ng-click="listener.generateQuick(labyrinthe, labyrinthe2)">Quick Generate</span> | 
    </h1>
    <h2>
      <a href="https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_de_labyrinthe#Exploration_exhaustive">Exploration exhaustive</a>
    </h2>
    <h3>
      | <span>Iteration {{labyrinthe2.iteration}}</span> |
      <span ng-click="listener.resolveLabyrinthe(labyrinthe2)">Resolve</span> |
      <span ng-click="listener.resolveQuickLabyrinthe(labyrinthe2)">Quick Resolve</span> |
      <span>Steps: {{labyrinthe2.resolutionStep}}</span>
    </h3>
    <div class="bordure" ">
      <div 
        ng-repeat="ligne in labyrinthe2.cellules"
        class="line">
        <div 
          ng-repeat="cellule in ligne"
          ng-class="labyrinthe2.getCssClass(cellule)"><!--{{cellule.processed}}--></div>
      </div>
    </div>
  </div>
  <div style="display: inline-block; position: relative;">
    <h1>VS</h1>
  </div>
  <!-- <br/><br/><br/> -->
  <div style="display: inline-block; position: relative;">
    <h2>
      <a href="https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_de_labyrinthe#Fusion_al%C3%A9atoire_de_chemins">Fusion aléatoire de chemins</a>
    </h2>
    <h3>
      | <span>Iteration {{labyrinthe.iteration}}</span> |
      <span ng-click="listener.resolveLabyrinthe(labyrinthe)">Resolve</span> |
      <span ng-click="listener.resolveQuickLabyrinthe(labyrinthe)">Quick Resolve</span> |
      <span>Steps: {{labyrinthe.resolutionStep}}</span>
    </h3>
    <div class="bordure">
      <div 
        ng-repeat="ligne in labyrinthe.cellules"
        class="line">
        <div 
          ng-repeat="cellule in ligne"
          ng-class="labyrinthe.getCssClass(cellule)"><!-- {{cellule.zoneId}} --></div>
      </div>
    </div>
  <div>
    <!-- <br/><br/> -->
</div>
<script type="text/javascript">
  
var app = angular.module('myApp', []);

// https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_de_labyrinthe#Fusion_al%C3%A9atoire_de_chemins
app.service('comprehensiveExploration', function() {
  this._getPossibleWallsToRemove = function(cellule, labyrinthe) {
    var possibleWallsToRemove = [];
    // S'il y une cellule à gauche
    if (cellule.x > 0
        // Et qu'il y un mur
        // && (cellule.value & 0x4) == 0x4
        // Et que la cellule de gauche n'a pas été traitée
        && labyrinthe.cellules[cellule.y][cellule.x - 1].processed == false) {
      possibleWallsToRemove.push({
        orientation: 0x4,
        opposite: 0x1,
        nextCellule: labyrinthe.cellules[cellule.y][cellule.x - 1]
      });
    }
    // S'il y une cellule à droite
    if (cellule.x < (labyrinthe.width - 1)
        // Et qu'il y un mur
        // && (cellule.value & 0x1) == 0x1
        // Et que la cellule de droite n'a pas été traitée
        && labyrinthe.cellules[cellule.y][cellule.x + 1].processed == false) {
      possibleWallsToRemove.push({
        orientation: 0x1,
        opposite: 0x4,
        nextCellule: labyrinthe.cellules[cellule.y][cellule.x + 1]
      });
    }
    // S'il y une cellule en haut
    if (cellule.y > 0
        // Et qu'il y un mur
        // && (cellule.value & 0x2) == 0x2
        // Et que la cellule en haut n'a pas été traitée
        && labyrinthe.cellules[cellule.y - 1][cellule.x].processed == false) {
      possibleWallsToRemove.push({
        orientation: 0x2,
        opposite: 0x8,
        nextCellule: labyrinthe.cellules[cellule.y - 1][cellule.x]
      });
    }
    // S'il y une cellule en bas
    if (cellule.y < (labyrinthe.height - 1)
        // Et qu'il y un mur
        // && (cellule.value & 0x8) == 0x8
        // Et que la cellule en bas n'a pas été traitée
        && labyrinthe.cellules[cellule.y + 1][cellule.x].processed == false) {
      possibleWallsToRemove.push({
        orientation: 0x8,
        opposite: 0x2,
        nextCellule: labyrinthe.cellules[cellule.y + 1][cellule.x]
      });
    }
    return possibleWallsToRemove;
  }

  this._breakWall = function(cellule, wallToRemove, labyrinthe) {
    // console.log('before: ' + cellule.value + ' ' + wallToRemove.nextCellule.value);
    var mask = 0xF ^ wallToRemove.orientation;
    cellule.value = cellule.value & mask;
    var oppositeMask = 0xF ^ wallToRemove.opposite;
    wallToRemove.nextCellule.value = wallToRemove.nextCellule.value & oppositeMask;
    // console.log('after: ' + cellule.value + ' ' + wallToRemove.nextCellule.value);
  } 

  this.init = function(labyrinthe) {
    for (var j = 0; j < labyrinthe.height; j++) {
      var ligne = labyrinthe.cellules[j];
      // console.log('ligne: ' + JSON.stringify(ligne));
      for (var i = 0; i < labyrinthe.width; i++) {
        var cellule = ligne[i];
        cellule.processed = false;
        cellule.current = false;
        // console.log('zones[' + id + ']: ' + JSON.stringify(zones[id]));
      }
    }
    var firstCelluleX = Math.floor(Math.random() * labyrinthe.width);
    var firstCelluleY = Math.floor(Math.random() * labyrinthe.height);
    labyrinthe.lastOpenedCellules = [];
    labyrinthe.nextCellule = labyrinthe.cellules[firstCelluleY][firstCelluleX];
    labyrinthe.nextCellule.current = true;
    labyrinthe.iteration = 0;
  }

  this.generate = function(labyrinthe, finish) {
    // this._initCellules(labyrinthe);
    // console.log('Labyrinthe: ' + JSON.stringify(labyrinthe));

    if (labyrinthe.nextCellule != null) {
      var cellule = labyrinthe.nextCellule;
      cellule.processed = true;

      // Si la cellule est un cul de sac il faut trouver une cellule déjà traitée 
      // qui a au moins 1 cellule non traitée autour d'elle, à partir de laquelle repartir 
      // Tant que la cellule n'a pas de cellule non traitée (donc avec un mur) autour d'elle (haut bas gauche droite)
      var possibleWallsToRemove = [];
      while ((cellule != null)
              // Attention là c'est pas une condition c'est une affectation 
              && (possibleWallsToRemove = this._getPossibleWallsToRemove(cellule, labyrinthe)) 
              && (possibleWallsToRemove.length == 0)) {
        // On dépile les cellule précédentes qui avaient encore au moins 1 cellule non traitée autour d'elle
        // Jusqu'à ce qu'on trouve une cellule qui a une cellule non traitée autour d'elle
        labyrinthe.nextCellule = labyrinthe.lastOpenedCellules.pop();
        cellule.current = false;
        cellule = labyrinthe.nextCellule;
        // cellule.current = true;
      }

      if (cellule != null) {
        // console.log('labyrinthe.iteration: ' + labyrinthe.iteration + ', cellule: ' + JSON.stringify(cellule));
        // On choisit au hasard un mur dans la liste des murs cassables (min 1, max 4) autour de la cellule
        var wallToRemove = possibleWallsToRemove[Math.floor(Math.random() * possibleWallsToRemove.length)];
        // On le casse
        this._breakWall(cellule, wallToRemove, labyrinthe);
        // S'il reste encore au moins 1 cellule non traitée autour de la cellule après ça
        if (possibleWallsToRemove.length - 1 > 0) {
          // On empile la cellule dans la liste des cellules ayant encore au moins 1 cellule non traitée autour d'elle 
          // Donc avec un mur à casser
          labyrinthe.lastOpenedCellules.push(cellule);
        }
        labyrinthe.nextCellule = wallToRemove.nextCellule;
        labyrinthe.nextCellule.current = true;
        cellule.current = false;
      } else {
        console.log('comprehensiveExploration finished');
        finish();
      }
    } else {
      console.log("ERROR labyrinthe.nextCellule is null");
    }
    labyrinthe.iteration++;
    // console.log("INFO labyrinthe.iteration: " + labyrinthe.iteration);
  }
});

// https://fr.wikipedia.org/wiki/Mod%C3%A9lisation_math%C3%A9matique_de_labyrinthe#Fusion_al%C3%A9atoire_de_chemins
app.service('randomWayFusion', function() {
  this._initZones = function(labyrinthe) {
    var zones = [];
    var id = 0;
    for (var j = 0; j < labyrinthe.height; j++) {
      var ligne = labyrinthe.cellules[j];
      // console.log('ligne: ' + JSON.stringify(ligne));
      for (var i = 0; i < labyrinthe.width; i++) {
        var cellule = ligne[i];
        zones[id] = {
          id: id,
          cellules: [ cellule ]
        };
        cellule.zoneId = id;
        // console.log('zones[' + id + ']: ' + JSON.stringify(zones[id]));
        id++;
      }
    }
    labyrinthe.zones = zones;
  }

  this._initWalls = function(labyrinthe) {
    var walls = [];
    var id = 0;
    // On ne traite pas les murs extérieurs, on fera un trou de chaque côté plus tard
    for (var j = 0; j < labyrinthe.height; j++) {
      // console.log('ligne: ' + JSON.stringify(ligne));
      for (var i = 0; i < labyrinthe.width; i++) {
        if (j < (labyrinthe.height - 1)) {
          var wallHorizontal = {
            id: id,
            type: "h",
            celluleTop: labyrinthe.cellules[j][i],
            celluleBottom: labyrinthe.cellules[j + 1][i],
            multiZones: true
          }
          walls[id] = wallHorizontal;
          // console.log('walls[' + id + ']: ' + JSON.stringify(walls[id]));
          id++;
        }
        if ( i < (labyrinthe.width - 1)) {
          var wallVertical = {
            id: id,
            type: "v",
            celluleLeft: labyrinthe.cellules[j][i],
            celluleRight: labyrinthe.cellules[j][i + 1],
            multiZones: true
          }
          walls[id] = wallVertical;
          // console.log('walls[' + id + ']: ' + JSON.stringify(walls[id]));
          id++;
        }
      }
    }
    labyrinthe.walls = walls;
  }

  this.init = function(labyrinthe) {
    this._initZones(labyrinthe);
    this._initWalls(labyrinthe);
    labyrinthe.iteration = 0;
  }

  this.generate = function(labyrinthe, finish) {
    // Au départ:
    // * Chaque zone contient 1 cellule 
    // ==> On a donc autant de zones que de cellules
    // * Toutes les cellules ont 4 murs
    // ==> On a donc:
    //    (labyrinthe.width + 1) murs verticaux
    //    (labyrinthe.height + 1) murs horizontaux
    
    var zones = labyrinthe.zones;
    // console.log('zones: ' + JSON.stringify(zones));
    var walls = labyrinthe.walls;

    // Nombre d'itérations: labyrinthe.width * labyrinthe.height - 1
    // Ou sinon lorsqu'il ne reste plus qu'une seule zone
    // for (var i = 0; i < (labyrinthe.width * labyrinthe.height - 1); i++) {
    if (walls.length > 0) {
      var wallIdToDelete = Math.floor(Math.random() * walls.length);
      // console.log('remaing walls: ' + walls.length + ', wallIdToDelete: ' + walls[wallIdToDelete].id);
      var wallToDelete = walls[wallIdToDelete];
      if (wallToDelete.type == "h") {
        // Les cellules de la zone du bas sont recopiées dans la zone du haut
        var zoneTop = zones[wallToDelete.celluleTop.zoneId];
        var zoneBottom = zones[wallToDelete.celluleBottom.zoneId];
        for (var j = 0; j < zoneBottom.cellules.length; j++) {
          var cellule = zoneBottom.cellules[j];
          // console.log('cellule:' + JSON.stringify(cellule) + ' to zoneId: ' + zoneTop.id);
          cellule.zoneId = zoneTop.id;
        }
        zoneTop.cellules = zoneTop.cellules.concat(zoneBottom.cellules);

        // On supprime le mur du bas (0x8) de la cellule du haut...
        wallToDelete.celluleTop.value = wallToDelete.celluleTop.value & 0x7;
        // ... et le mur du haut (0x2) de la cellule du bas...
        wallToDelete.celluleBottom.value = wallToDelete.celluleBottom.value & 0xD;
      }
      if (wallToDelete.type == "v") {
        // Les cellules de la zone de droite sont recopiées dans la zone de gauche
        var zoneLeft = zones[wallToDelete.celluleLeft.zoneId];
        var zoneRight = zones[wallToDelete.celluleRight.zoneId];
        for (var j = 0; j < zoneRight.cellules.length; j++) {
          var cellule = zoneRight.cellules[j];
          // console.log('cellule:' + JSON.stringify(cellule) + ' to zoneId: ' + zoneLeft.id);
          cellule.zoneId = zoneLeft.id;
        }
        zoneLeft.cellules = zoneLeft.cellules.concat(zoneRight.cellules);
        // On supprime le mur de droite (0x1) de la cellule de gauche...
        wallToDelete.celluleLeft.value = wallToDelete.celluleLeft.value & 0xE;
        // ... et le mur de gauche (0x4) de la cellule du droite...
        wallToDelete.celluleRight.value = wallToDelete.celluleRight.value & 0xB;
      }
      // On supprime le mur de la liste des murs
      walls.splice(walls.indexOf(wallToDelete), 1);
      // On n'a plus besoin de gérer la suppression des murs entre 2 cellules d'une même zone
      // Donc on retient uniquement les murs entre 2 zones distinctes
      var remainingWalls = [];
      for (var j = 0; j < walls.length; j++) {
        var wall = walls[j];
        if (wall.type == "h") {
          if (wall.celluleTop.zoneId != wall.celluleBottom.zoneId) {
            remainingWalls.push(wall);
          }
        }
        if (wall.type == "v") {
          if (wall.celluleLeft.zoneId != wall.celluleRight.zoneId) {
            remainingWalls.push(wall);
          }
        }
      }
      labyrinthe.walls = remainingWalls;
      // $scope.$apply();
    } else {
      console.log('randomWayFusion finished');
      finish();
    }
    // return labyrinthe;
    labyrinthe.iteration++;
  }
});

app.service('resolve', function() {
  this._setTreeTo = function(cellule, labyrinthe, fromCellule) {
    // S'il y une cellule à gauche
    if (cellule.x > 0
        // Et qu'il y a pas de mur
        && (cellule.value & 0x4) == 0
        // Et que ce n'est pas la cellule d'où on vient
        && fromCellule.x != (cellule.x - 1)) {
          labyrinthe.cellules[cellule.y][cellule.x - 1].nextCelluleToEnd = cellule;
          this._setTreeTo(labyrinthe.cellules[cellule.y][cellule.x - 1], labyrinthe, cellule);
    }
    // S'il y une cellule à droite
    if (cellule.x < (labyrinthe.width - 1)
        // Et qu'il y a pas de mur
        && (cellule.value & 0x1) == 0
        // Et que ce n'est pas la cellule d'où on vient
        && fromCellule.x != (cellule.x + 1)) {
          labyrinthe.cellules[cellule.y][cellule.x + 1].nextCelluleToEnd = cellule;
          this._setTreeTo(labyrinthe.cellules[cellule.y][cellule.x + 1], labyrinthe, cellule);
    }
    // S'il y une cellule en haut
    if (cellule.y > 0
        // Et qu'il y a pas de mur
        && (cellule.value & 0x2) == 0
        // Et que ce n'est pas la cellule d'où on vient
        && fromCellule.y != (cellule.y - 1)) {
          labyrinthe.cellules[cellule.y - 1][cellule.x].nextCelluleToEnd = cellule;
          this._setTreeTo(labyrinthe.cellules[cellule.y - 1][cellule.x], labyrinthe, cellule);
    }
    // S'il y une cellule en bas
    if (cellule.y < (labyrinthe.height - 1)
        // Et qu'il y a pas de mur
        && (cellule.value & 0x8) == 0
        // Et que ce n'est pas la cellule d'où on vient
        && fromCellule.y != (cellule.y + 1)) {
          labyrinthe.cellules[cellule.y + 1][cellule.x].nextCelluleToEnd = cellule;
          this._setTreeTo(labyrinthe.cellules[cellule.y + 1][cellule.x], labyrinthe, cellule);
    }
  }
  this.initEnd = function(celluleEnd, labyrinthe) {
    console.log('Resolution initialization start');
    this._setTreeTo(celluleEnd, labyrinthe, celluleEnd);
    labyrinthe.resolutionStep = 0;
    console.log('Resolution initialization stop');
  }
  this.fromCellule = function(cellule, finish, labyrinthe) {
    console.log('Resolution start')
    if (cellule != null) {
      cellule.visited = true;
      cellule = cellule.nextCelluleToEnd;
      labyrinthe.resolutionStep++;
    } else {
      console.log('Resolution finished')
      finish();
    }
    return cellule;
  }
});

app.controller('myCtrl', function($scope, $timeout, $document, randomWayFusion, comprehensiveExploration, resolve) {
	console.log('Setting labyrinthe...');
	var Labyrinthe = function() {
    this.width = 200;
    this.height = 90;
    this.cellules = [];
    for (var j = 0; j < this.height; j++) {
      this.cellules[j] = [];
      for (var i = 0; i < this.width; i++) {
        this.cellules[j][i] = {
          x: i,
          y: j,
          value: 0xF
        }
      }
    }
    this.getCssClass = function(cellule) {
      var cssClass = "cellule x" + cellule.value.toString(16).toUpperCase();
      if (cellule.current) {
        cssClass = cssClass + " current";
      }
      if (cellule.processed) {
        cssClass = cssClass + " processed";
      }
      if (cellule.visited) {
        cssClass = cssClass + " visited";
      }
      return cssClass;
    }
  }
  $scope.labyrinthe = new Labyrinthe();
  // $scope.$watch($scope.labyrinthe, null, true);
  $scope.labyrinthe2 = new Labyrinthe();
  // $scope.$watch($scope.labyrinthe2.cellules[][].value);
  randomWayFusion.init($scope.labyrinthe);
  comprehensiveExploration.init($scope.labyrinthe2);
  // $scope.$watch($scope.labyrinthe2.cellules, null, true);
	// console.log('labyrinthe: ' + JSON.stringify($scope.labyrinthe));

  var EventListener = function(randomWayFusion, labyrinthe, comprehensiveExploration, labyrinthe2, resolve) {
    var started = false;
    this.generate = function(labyrinthe, labyrinthe2) {
      if (! started) {
        started = true;
        this.generateRandomWayFusion(labyrinthe);
        this.generateComprehensiveExploration(labyrinthe2);
      } else {
        console.log('generation already started');
      }
    }
    this.generateQuick = function(labyrinthe, labyrinthe2) {
      if (! started) {
        started = true;
        this.generateQuickRandomWayFusion(labyrinthe);
        this.generateQuickComprehensiveExploration(labyrinthe2);
      } else {
        console.log('generation already started');
      }
    }
    this.generateComprehensiveExploration = function(labyrinthe) {
      function finish() {
        clearInterval(intervalId);
      }
      // On lance la génération en boucle en async pour qu'angularjs affiche bien le labyrinthe
      // au fur & à mesure de sa génération
      // Quand c'est fini la callback "finish" arrête la boucle
      var intervalId = setInterval(function() {
        $scope.$evalAsync(comprehensiveExploration.generate(labyrinthe, finish));
      }, 0);
    }
    this.generateRandomWayFusion = function(labyrinthe) {
      function finish() {
        clearInterval(intervalId);
      }
      // On lance la génération en boucle en async pour qu'angularjs affiche bien le labyrinthe
      // au fur & à mesure de sa génération
      // Quand c'est fini la callback "finish" arrête la boucle
      var intervalId = setInterval(function() {
        $scope.$evalAsync(randomWayFusion.generate(labyrinthe, finish)) 
      }, 0);
    }
    this.generateQuickComprehensiveExploration = function(labyrinthe) {
      var finished = false;
      function finish() {
        finished = true;
      }
      while (! finished) {
        comprehensiveExploration.generate(labyrinthe, finish);
      }
    }
    this.generateQuickRandomWayFusion = function(labyrinthe) {
      var finished = false;
      function finish() {
        finished = true;
      }
      while (! finished) {
        randomWayFusion.generate(labyrinthe, finish);
      }
    }
    this.resolveLabyrinthe = function(labyrinthe) {
      var celluleStart = labyrinthe.cellules[0][0];
      var celluleEnd = labyrinthe.cellules[labyrinthe.height - 1][labyrinthe.width - 1];
      var cellule = celluleStart;
      function finish() {
        clearInterval(intervalId);
      }
      resolve.initEnd(celluleEnd, labyrinthe);
      var intervalId = setInterval(function() {
        $scope.$evalAsync(cellule = resolve.fromCellule(cellule, finish, labyrinthe));
      }, 0);
    }
    this.resolveQuickLabyrinthe = function(labyrinthe) {
      var celluleStart = labyrinthe.cellules[0][0];
      var celluleEnd = labyrinthe.cellules[labyrinthe.height - 1][labyrinthe.width - 1];
      var cellule = celluleStart;
      var finished = false;
      function finish() {
        finished = true;
      }
      resolve.initEnd(celluleEnd, labyrinthe);
      while (! finished) {
        cellule = resolve.fromCellule(cellule, finish, labyrinthe);
      }
    }
  }
  var eventListener = new EventListener(randomWayFusion, $scope.labyrinthe, comprehensiveExploration, $scope.labyrinthe2, resolve);
  $scope.listener = eventListener;
});


  </script>
</body>
</html>
